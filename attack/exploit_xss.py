print("DEBUG: Script starting...")
import grpc
import sys
import os
import time

# ANSI Colors for terminal output
GREEN = '\033[92m'
RED = '\033[91m'
YELLOW = '\033[93m'
RESET = '\033[0m'
CYAN = '\033[96m'

# Setup path to import generated gRPC stubs
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    import library_pb2
    import library_pb2_grpc
except ImportError:
    print(f"{RED}‚ùå Error: Compiled proto files not found.{RESET}")
    print("Run: python -m grpc_tools.protoc -I../modules/dotnet-grpc-library-api/LibrarySystem.Contracts/Protos --python_out=./attack --grpc_python_out=./attack ../modules/dotnet-grpc-library-api/LibrarySystem.Contracts/Protos/library.proto")
    sys.exit(1)

# XSS Attack Vector Suite
# Tuple Format: (Scenario Name, Payload, Description)
XSS_VECTORS = [
    (
        "Standard Script Tag", 
        "<script>alert('RASP')</script>", 
        "The classic proof of concept."
    ),
    (
        "Attribute Breakout", 
        "\"><img src=x onerror=alert(1)>", 
        "Breaks out of input value attributes to inject handlers."
    ),
    (
        "Protocol Wrapper (Obfuscated)", 
        "jAvAsCrIpT:alert(1)", 
        "Mixed case protocol handler often missed by regex."
    ),
    (
        "Hex Entity Encoding", 
        "&#x3C;script&#x3E;alert(1)&#x3C;/script&#x3E;", 
        "Uses HTML entities to hide the brackets."
    ),
    (
        "SVG OnLoad Vector", 
        "<svg/onload=alert(1)>", 
        "Vector that doesn't require user interaction."
    ),
    (
        "Polyglot (JaVaScRiPt)", 
        "javascript://%250Aalert(1)//", 
        "Complex payload combining protocol and URL encoding tricks."
    ),
    (
        "Recursive/Nested Tags", 
        "<scr<script>ipt>alert(1)</script>", 
        "Attempts to bypass single-pass sanitizers."
    ),
    (
        "Safe Control", 
        "Advanced Algorithms in C# 10.0", 
        "Legitimate title. Should NOT be blocked (False Positive check)."
    )
]

def run_xss_suite(target):
    print(f"[*] Connecting to target: {CYAN}{target}{RESET}")
    print(f"[*] Starting RASP XSS Validation Suite...\n")
    
    blocked_count = 0
    bypassed_count = 0
    false_positives = 0

    # Create insecure channel (PoC environment)
    with grpc.insecure_channel(target) as channel:
        stub = library_pb2_grpc.LibraryStub(channel)
        
        for name, payload, description in XSS_VECTORS:
            print(f"üîπ Testing: {CYAN}{name}{RESET}")
            print(f"   Payload: \"{payload}\"")
            
            expect_block = name != "Safe Control"
            
            try:
                # Send payload via gRPC 'CreateBook' method
                # The RASP interceptor inspects ALL string fields, including Title
                stub.create_book(library_pb2.CreateBookRequest(
                    title=payload, 
                    author="XSS Bot",
                    publication_year=2025,
                    pages=100,
                    total_copies=1
                ))
                
                # If we reach here, the server accepted the request (200 OK)
                if expect_block:
                    print(f"{RED}   [FAIL] BYPASS DETECTED! RASP asleep at the wheel.{RESET}")
                    bypassed_count += 1
                else:
                    print(f"{GREEN}   [PASS] Legitimate request accepted correctly.{RESET}")

            except grpc.RpcError as e:
                # Check if the error is actually a security block (PermissionDenied or InvalidArgument)
                # Note: Your RASP might throw InvalidArgument based on the Source Generator logic
                if e.code() == grpc.StatusCode.INVALID_ARGUMENT or e.code() == grpc.StatusCode.PERMISSION_DENIED:
                    if expect_block:
                        print(f"{GREEN}   [SUCCESS] RASP Blocked the attack!{RESET}")
                        print(f"   Log: {e.details()}")
                        blocked_count += 1
                    else:
                        print(f"{RED}   [FAIL] FALSE POSITIVE! RASP blocked a legitimate user.{RESET}")
                        false_positives += 1
                elif e.code() == grpc.StatusCode.UNAVAILABLE:
                    print(f"{RED}   [ERROR] Connection failed. Is the server running on {target}?{RESET}")
                    return False
                else:
                    print(f"{YELLOW}   [WARN] Unexpected server error: {e.code()} - {e.details()}{RESET}")

            print("-" * 60)
            time.sleep(0.05) # Prevent log overlap

    # Final Report
    print("\nüìä XSS Security Report")
    print("=" * 40)
    print(f"Total Scenarios:  {len(XSS_VECTORS)}")
    print(f"Attacks Blocked:  {GREEN}{blocked_count}{RESET}")
    print(f"Bypasses Found:   {RED}{bypassed_count}{RESET}")
    print(f"False Positives:  {RED if false_positives > 0 else GREEN}{false_positives}{RESET}")
    print("=" * 40)

    return (bypassed_count == 0) and (false_positives == 0)

if __name__ == '__main__':
    # Default target set to the correct port we found earlier
    target_url = 'localhost:5049' 
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
        
    success = run_xss_suite(target_url)
    
    if success:
        sys.exit(0)
    else:
        sys.exit(1)