print("DEBUG: Script starting...")
import grpc
import sys
import os
import time

# ANSI Colors for terminal output
GREEN = '\033[92m'
RED = '\033[91m'
YELLOW = '\033[93m'
RESET = '\033[0m'

# Setup path to import generated gRPC stubs
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    import library_pb2
    import library_pb2_grpc
except ImportError:
    print(f"{RED}âŒ Error: Compiled proto files not found.{RESET}")
    print("Run: python -m grpc_tools.protoc -I../src/Rasp.Instrumentation.Grpc/Protos ...")
    sys.exit(1)

# Attack Vector Suite
# Tuple Format: (Scenario Name, Payload, Description)
ATTACK_VECTORS = [
    (
        "Basic Tautology", 
        "' OR '1'='1", 
        "Classic SQL injection to bypass boolean checks."
    ),
    (
        "Stacked Queries", 
        "'; DROP TABLE Books; --", 
        "Extremely dangerous payload trying to execute a second command."
    ),
    (
        "Comment Obfuscation", 
        "'/**/OR/**/1=1", 
        "Uses inline SQL comments to evade simple ' OR ' string matching."
    ),
    (
        "URL Encoded Bypass", 
        "%27%20OR%201=1", 
        "Attempts to hide special characters using URL encoding."
    ),
    (
        "Auth Bypass Pattern", 
        "admin' --", 
        "Attempts to truncate the query rest to log in as admin."
    ),
    (
        "Safe Control", 
        "Harry Potter and the Methods of Rationality", 
        "Legitimate title. Should NOT be blocked (False Positive check)."
    )
]

def run_exploit_suite(target):
    print(f"[*] Connecting to target: {target}")
    print(f"[*] Starting RASP Evasion Test Suite...\n")
    
    blocked_count = 0
    bypassed_count = 0
    false_positives = 0

    # Create insecure channel (PoC environment)
    with grpc.insecure_channel(target) as channel:
        stub = library_pb2_grpc.LibraryStub(channel)
        
        for name, payload, description in ATTACK_VECTORS:
            print(f"ðŸ”¹ Testing: {name}")
            print(f"   Payload: \"{payload}\"")
            
            # Identify if this is an expected attack or a safe control
            expect_block = name != "Safe Control"
            
            try:
                # Send payload via gRPC 'CreateBook' method
                stub.CreateBook(library_pb2.CreateBookRequest(
                    title=payload, 
                    author="Red Team Bot",
                    publication_year=2025,
                    pages=100,
                    total_copies=1
                ))
                
                # If we reach here, the server accepted the request (200 OK)
                if expect_block:
                    print(f"{RED}   [FAIL] BYPASS DETECTED! RASP did not block this payload.{RESET}")
                    bypassed_count += 1
                else:
                    print(f"{GREEN}   [PASS] Legitimate request accepted correctly.{RESET}")

            except grpc.RpcError as e:
                # Check if the error is actually a security block (PermissionDenied)
                if e.code() == grpc.StatusCode.PERMISSION_DENIED:
                    if expect_block:
                        print(f"{GREEN}   [SUCCESS] RASP Blocked the attack!{RESET}")
                        print(f"   Log: {e.details()}")
                        blocked_count += 1
                    else:
                        print(f"{RED}   [FAIL] FALSE POSITIVE! RASP blocked a legitimate user.{RESET}")
                        false_positives += 1
                else:
                    print(f"{YELLOW}   [WARN] Unexpected server error: {e.code()}{RESET}")

            print("-" * 60)
            time.sleep(0.1) # Prevent log overlap in console

    # Final Report
    print("\nðŸ“Š RASP Security Assessment Report")
    print("=" * 40)
    print(f"Total Scenarios:  {len(ATTACK_VECTORS)}")
    print(f"Attacks Blocked:  {GREEN}{blocked_count}{RESET}")
    print(f"Bypasses Found:   {RED}{bypassed_count}{RESET}")
    print(f"False Positives:  {RED if false_positives > 0 else GREEN}{false_positives}{RESET}")
    print("=" * 40)

    # Return success only if NO bypasses occurred and NO false positives occurred
    return (bypassed_count == 0) and (false_positives == 0)

if __name__ == '__main__':
    # Default target
    target_url = 'localhost:5001' 
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
        
    success = run_exploit_suite(target_url)
    
    # Exit code for CI/CD pipelines
    if success:
        sys.exit(0)
    else:
        sys.exit(1)